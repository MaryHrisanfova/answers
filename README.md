# answers
Хрисанфова Мария Михайловна.
Java questionary
1. Какова разница между абстрактным классом и интерфейсом?
Абстрактный класс - это класс, представляющий собой обобщенное понятие в предметной области. Объекты такого класса нельзя создавать (и не имеет смысла). Такие классы необходимы для создания методов, которые будут одинаковыми для классов-потомков абстрактного класса. Классический пример абстрактного класса - класс Фигура. Невозможно создать объект типа фигура. Но возможно (и имеет смысл) создать класс Треугольник, Круг и т.д. При этом они унаследуют методы класса Фигура (или получат возможность эти методы переопределить). Например, у класса Фигура есть методы Нарисовать и Стереть. Каждая фигура может иметь метод Нарисовать и Стереть, соответственно, объекты классов Треугольник и Круг смогут вызвать эти методы.
Реализация абстрактного класса происходит с помощью слова abstract.
Интерфейс - описывает только абстрактные методы и статические константы. Интерфейсы служат для описания одинакового функционала разных классов. Таким образом, зная название и назначение метода, можно его вызывать для использования его функционала применительно к объектам определенного класса. Графический интерфейс программы в общем случае - тоже интерфейс т.к. показывает, что можно сделать с каким-либо объектом. Как и для абстрактных классов нельзя создать объект типа интерфейс. 
Реализация  - с помощью слова implements. 
Примеры интерфейсов:
	•	Comparable (метод интерфейса sort(…) позволяет упорядочивать массив объектов по определенному в методе compareTo (…)правилу). 
	•	Clonable (метод clone(…) возвратит точную копию указанного объекта)
	
Отличие в том, что интерфейсы могут только реализовываться определенным классом или наследоваться другим интерфейсом и не могут иметь потомков, в то время как абстрактные классы могут иметь потомков, но их функционал не может быть передан произвольному классу (только потомку).
Т.е. интерфейсы используются для выполнения определенных действий над объектом,  абстрактные классы - для определения общих для нескольких классов методов.

2. Как «насильно» вызвать сборку мусора?
Вызов сборки мусора осуществляется методом finalize(). Однако, garbage collector (сборщик мусора) сам решает, когда удалить ссылку на данный объект из heap (“кучи” - области памяти, где хранятся ссылки на объекты). Вызов метода finalize() следует рассматривать как рекомендацию удалить данный объект. 

3. Когда требуется явное приведение классов?
Явное приведение требуется, например,  при необходимости получить переменную, занимающий меньше памяти (например, приведение longInt к int) . Также это может быть нужно для выполнения операций над объектами разного типа (сложения значений типа int и double  - для получения целочисленного значения придется переменную типа  double  привести к типу int).  Это следует делать, если мы уверены в том, что переменная не выходит за границы типа int и является целочисленный. Аналогично с объектами - если объект класса-потомка необходимо преобразовать в его класс-предок, то необходимо использовать явное приведение типов с возможной потерей информации у объекта класса-потомка т.к. он, вероятно, содержит поля, методы, которые не содержит класс-родитель.
Это называется “небезопасным приведением типов”.  

4.Чем конструкторы отличаются от других методов?
Конструктор - это метод, который автоматически вызывается у объекта класса при его(объекта) создании. С помощью конструктора может происходить инициализация объекта (в качестве параметров метода-конструктора передаются значения полей объекта, в конструкторе происходит присвоение этих значений полям). Также в конструкторе можно задать значения для полей класса, которые будут инициализированы одним и тем же значением при создании объектов. Конструктор должен называться по имени класса. Другие методы класса - это, как правило, действия над объектом; эти методы могут использовать поля объекта, инициализированные в конструкторе. Если конструктор явно не создан, то он создается пустым автоматически при компиляции. В отличие от метода, конструктор ничего не возвращает (метод может возвращать значение в результате своего выполнения). Конструктор вызывается при создании объекта с помощью ключевого слова new, в то время как другие методы должны вырываться явно (по своему имени). 

5. Можно ли вызывать конструкторы один из другого, если их в классе несколько?
Да, однако если конструкторов в одном классе несколько, то они обязаны иметь параметры разного типа или разное количество параметров, чтобы явно дать “понять” компилятору, какой конструктор вызвать.  Вызов одного конструктора из другого осуществляется с помощью ключевого слова this.  При этом конструктор, вызывающий другой конструктор, вызывается с помощью new, затем вызванный конструктор вызывает конструктор с помощью слова this и соответствующими параметрами.

6. В чем разница между JDK и JRE?
JDK(Java Development Kit) - компонент для разработчика (содержит JVM, библиотеки, компилятор, документацию, примеры, утилиты для создания документации и т.д). JRE(Java Runtime Enviroment) -  среда выполнения программ (с библиотеками). JDK - необходимо разработчику, JRE - необходимо пользователю для запуска программ (включает JVM).

7.Имеет ли значение в каком порядке перехватывать исключения FileNotFoundException и IOExceptipon?
Имеет т.к. сначала обрабатываются более конкретные, подходящие исключения (при поиске будет искаться совпадающий класс. а в случае, если такой класс не найден - будут искаться его предки). FileNotFoundException наследуется от IOExceptipon, поэтому перехватывать сначала следует FileNotFoundException.

8.Могут ли внутренние классы, описанные внутри метода, иметь доступ к локальным переменным этого метода?
Нет, локальные переменные метода видны только в своем методе. 

9. Как подкласс может обратиться к методу или конструктору из суперкласса?
С помощью ключевого слова super, которое указывает на класс-предок. Таким образом конструктор суперкласс можно вызвать так: super(указать значения параметров);. Вызов метода super() всегда должно быть первым оператором в конструкторе класса-потомка. Можно вызвать метод super() с разными параметрами в случае, если конструктор у класса-предка перегружен. Для вызова метода суперкласса нужно использовать  слово super аналогично слову this. Так можно вызвать метод суперкласса: super.method1.

10. В чем разница между очередью и стеком?
Очередь (Queu) - интерфейс, унаследованный от коллекций, предназначенный для помещения объектов в эту коллекцию перед их обработкой в нужном порядке. Имеет операции вставки, чтения, контроля. Как правильно порядок хранения - это FIFO first-in-first-out, "первым вошел - первым вышел”).
Стек - это наследник от Vector, хранит объекты в порядке LIFO (last-in-first-out, "последним вошел - первым вышел”).

11.Что вам приходит в голову, когда вы слышите о новом поколении (young generation) в Java?
Young generation - область в garbage collector, где располагаются новые созданные объекты.

12. Есть два класса: A и B. Класс B должен информировать класс A когда случается некое важное событие. Какой design-pattern вы должны реализовать? Listener - объект, который ждет наступления события у объекта класса В, затем передает информацию о наступлении события в объект А.

13.Какой модификатор доступа надо указать в классе, чтобы доступ к нему имели только классы из того же пакета?

14. Чем отличается статический внутренний класс от просто внутреннего класса?
Просто внутренний класс имеет доступ к полям содержащего класса, даже если они объявлены как  private. Статические внутренние классы - не имеют доступа к членам внешнего класса.  Статический внутренний класс не имеет связи с содержим классом (не требуется создание объекта содержащего класса), внутренний класс же требует создания объекта содержащего класса.

15. можно ли обратиться к не-статической переменной из статического метода?
Нет, т.к. статический метод определяется вне класса. 

16. какие типы данных есть в Java?
Примитивные типы: int (целочисленный), char (символ), float, byte(байт), double (число с плавающей запятой), boolean (логический), void.
Классы-обертки: Integer, Sting (строка), Float,…
Big-классы (для работы с очень большими числами).
Переменные.
Литералы.

17. Чем отличаются переопределение (Override) и перегрузка (Overload)
Override - создание нового метода с сигнатурой уже существующего метода, с аннотацией @Override, с отличающейся логикой метода. Используется для изменения метода класса-предка у класса-потомка.
Overload - создание нового метода с другой сигнатурой (имя метода - то же, параметры - другие). Применяется для использования метода, выполняющего одно и то же действие по-разному (конструкторы с разными параметрами).

18. Что такое итератор?
Итератор - объект, необходимый для последовательного перемещения по списку и получения ссылки на объект в списке.  

19. Перечислите основные категории исключительных ситуаций
Error - проверяемое исключение (его можно перехватить в программе). Ошибка, говорящая о том, что какая-то важная подсистема дала сбой и работает неправильно.
Fatal Error - полный крах системы.
RunTime- ошибка во время выполнения программы, неопровержимое исключение.
Warning - предупреждение, некритическое, допускаемое компилятором.

20. Какая разница между throw и throws?
throw - для явного выброса исключения программой: throw ThrowableInstance, где ThrowableInstance - объект типа Throwable. Если метод может вызывать исключения, которые он не обрабатывает, то необходимо описать его как throws. throws перечисляет типы возможных исключений: int method1() throws IOException{}

21. Зачем нужен блок finally?
Используется в блоке try{} catch(){}  для выполнения каких-либо операторов в любом случае: отработал блок try или произошло и отложилось исключение в блоке catch(). Используется, например, при работе с потоками, которые закрыть нужно в любом случае (закрытие происходит в блоке finally.

22.Что такое finalize?
Вызов сборки мусора осуществляется методом finalize(). Не рекомендуется использовать т.к. заведомо нельзя точно сказать, сработает ли он.

23. Перечислите все виды внутренних классов
Статические внутренние классы (static nasted) - не имеют доступа к нестатическим полям и методом содержащего класса.
Внутренние классы-члены (member inner): внутренние (ассоциируются с экземпляром класса), локальные (объявляются как правило в методе другого класса), анонимные (класс без имени, невозможность описания конструктора).
